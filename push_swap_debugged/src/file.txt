/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   checkstack.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ceaugust <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/04 16:18:15 by ceaugust          #+#    #+#             */
/*   Updated: 2025/02/04 16:31:36 by username         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h" 

// Helper function to check duplicates
int	has_duplicates(t_stack *stack)
{
	t_node	*current;
	t_node	*runner;

	current = stack->top;
	while (current)
	{
		runner = current->next;
		while (runner)
		{
			if (current->value == runner->value)
				return (1);
			runner = runner->next;
		}
		current = current->next;
	}
	return (0);
}

// Validate the stack
int	validate_stack(t_stack *stack_a)
{
	if (!stack_a || stack_a->size == 0)
		return (1);
	if (has_duplicates(stack_a))
		return (1);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_split.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ceaugust <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/06 15:03:17 by ceaugust          #+#    #+#             */
/*   Updated: 2025/02/06 15:03:22 by ceaugust         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

static size_t	wordcounter(const char *s, char c)
{
    size_t	wordcount;
    size_t	i;

    wordcount = 0;
    i = 0;
    while (s[i])
    {
        while (s[i] && s[i] == c)
            i++;
        if (s[i] && s[i] != c)
        {
            wordcount++;
            while (s[i] && s[i] != c)
                i++;
        }
    }
    return (wordcount);
}

static char	*wordextracter(const char *s, size_t *i, char c)
{
    size_t	wordlen;
    char	*word;

    wordlen = 0;
    while (s[*i] && s[*i] == c)
        (*i)++;
    while (s[*i + wordlen] && s[*i + wordlen] != c)
        wordlen++;
    word = ft_substr(s, *i, wordlen);
    *i += wordlen;
    return (word);
}

char	**ft_split(char const *s, char c)
{
    char	**ret;
    size_t	wordcount;
    size_t	i;
    size_t	j;

    i = 0;
    j = 0;
    if (!s)
        return (NULL);
    wordcount = wordcounter(s, c);
    ret = (char **)malloc(sizeof(char *) * (wordcount + 1));
    if (!ret)
        return (NULL);
    while (j < wordcount)
    {
        ret[j] = wordextracter(s, &i, c);
        if (!ret[j++])
            return (ft_free(ret, j - 1));
    }
    ret[j] = NULL;
    return (ret);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ceaugust <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/04 17:04:03 by ceaugust          #+#    #+#             */
/*   Updated: 2025/02/04 18:12:52 by ceaugust         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

void	print_stack(t_stack *stack, const char *name)
{
	t_node	*current;

	printf ("Stack %s: ", name);
	current = stack->top;
	while (current)
	{
		printf("%d ", current->value);
		current = current->next;
	}
	printf ("\n");
}

int	handle_errors(int ac, char **av, t_push_swap *ps)
{
	if (parse_input(ac, av, ps->stack_a) || has_duplicates(ps->stack_a))
	{
		free_push_swap(ps);
		write(2, "Error\n", 6);
		return (1);
	}
	print_stack(ps->stack_a, "A");
	if (is_sorted(ps->stack_a))
	{
		free_push_swap(ps);
		return (1);
	}
	return (0);
}

int	main(int ac, char **av)
{
	t_push_swap	*ps;

	if (ac < 2)
		return (0);
	ps = init_push_swap();
	if (!ps || handle_errors(ac, av, ps))
		return (1);
	if (ps->stack_a->size == 3)
		sort_three(ps);
	else if (ps->stack_a->size == 4)
	    sort_four(ps);
	else if (ps->stack_a->size == 5)
		sort_five(ps);
	else
		radix_sort(ps);
	print_stack(ps->stack_a, "A");
	free_push_swap(ps);
	return (0);
}
#include "push_swap.h"

/* ************************************************************************** */
/*                                                                            */
/*                            PARSE.C                                         */
/*                                                                            */
/*   This file contains functions for processing the command-line           */
/*   arguments and filling stack A with nodes in the intended order.        */
/*   The intended behavior is that the first number provided is at the top   */
/*   of stack A.                                                            */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"
#include <stdio.h>  // For debug prints

/*
** parse_values:
**  - Splits the string 'str' (which may contain multiple numbers separated
**    by spaces) into tokens.
**  - For each token, checks validity, converts it to an int, creates a node,
**    and pushes it onto stack A.
**
** To preserve the order, we iterate the tokens in reverse so that when push()
** (which inserts at the top) is called, the original order is preserved.
*/
int	parse_values(char *str, t_stack *stack)
{
	char	**values;
	int		count;
	int		i;
	int		value;
	t_node	*new_node;

	values = ft_split(str, ' ');
	if (!values)
		return (1);
	count = 0;
	while (values[count])
		count++;
	// Iterate tokens from last to first.
	i = count - 1;
	while (i >= 0)
	{
		printf("Parsing value: %s\n", values[i]);
		if (!is_valid_integer(values[i]))
		{
			printf("Invalid integer: %s\n", values[i]);
			ft_free(values, count);
			free_stack(stack);
			return (1);
		}
		value = ft_atoi(values[i]);
		printf("Converted value: %d\n", value);
		new_node = create_node(value);
		if (!new_node)
		{
			ft_free(values, count);
			free_stack(stack);
			return (1);
		}
		push(stack, new_node);
		print_stack(stack, "A");
		i--;
	}
	ft_free(values, count);
	return (0);
}

/*
** parse_input:
**  - Processes command-line arguments and fills stack A.
**
** To ensure that the first input argument becomes the top of stack A,
** we process the arguments in reverse order (from av[ac-1] down to av[1]).
*/
int	parse_input(int ac, char **av, t_stack *stack)
{
	int	i;

	if (ac < 2 || !stack)
		return (1);
	i = ac - 1;
	while (i >= 1)
	{
		printf("Processing argument: %s\n", av[i]);
		// Handle quoted argument if needed.
		if (av[i][0] == '"' || av[i][0] == '\'')
		{
			char *str = av[i] + 1;
			size_t len = ft_strlen(str);
			if (len > 0 && str[len - 1] == av[i][0])
				str[len - 1] = '\0';
			printf("Quoted argument after removing quotes: %s\n", str);
			if (parse_values(str, stack))
				return (1);
		}
		else
		{
			if (parse_values(av[i], stack))
				return (1);
		}
		i--;
	}
	return (0);
}

#include "push_swap.h"

// Initialize the push_swap program
t_push_swap *init_push_swap(void)
{
    t_push_swap *ps = (t_push_swap *)malloc(sizeof(t_push_swap));
    if (!ps)
        return (NULL);
    ps->stack_a = init_stack();
    ps->stack_b = init_stack();
    if (!ps->stack_a || !ps->stack_b)
    {
        free_push_swap(ps);
        return (NULL);
    }
    return (ps);
}
#include "push_swap.h"

// Rotate a stack upwards
void rotate(t_stack *stack)
{
    if (!stack || stack->size < 2)
        return;
    
    // Save pointer to the first node.
    t_node *first = stack->top;
    // Update the top pointer.
    stack->top = first->next;
    // Isolate the first node.
    first->next = NULL;
    
    // Traverse to the last node.
    t_node *current = stack->top;
    while (current->next)
        current = current->next;
    
    // Append the first node at the bottom.
    current->next = first;
    // Note: Do not modify stack->size (it stays the same)
}
// Rotate stack_a upwards
void ra(t_push_swap *ps)
{
    if (ps)
    {
        rotate(ps->stack_a);
        write(1, "ra\n", 3);
    }
}

// Rotate stack_b upwards
void rb(t_push_swap *ps)
{
    if (ps)
    {
        rotate(ps->stack_b);
        write(1, "rb\n", 3);
    }
}

// Rotate both stack_a and stack_b upwards
void rr(t_push_swap *ps)
{
    if (ps)
    {
        rotate(ps->stack_a);
        rotate(ps->stack_b);
        write(1, "rr\n", 3);
    }
}

#include "push_swap.h"

void	sort_four(t_push_swap *ps)
{
	if (!ps || !ps->stack_a || ps->stack_a->size != 4)
		return;
	push_min_to_b(ps); // Remove smallest
	sort_three(ps);    // Sort the remaining three elements in A
	pa(ps);
}
#include "push_swap.h"

void sort_three(t_push_swap *ps)
{
    if (!ps || !ps->stack_a)
        return;
    printf("sort_three: size = %d, a=%d, b=%d, c=%d\n", ps->stack_a->size,
       ps->stack_a->top->value,
       ps->stack_a->top->next->value,
       ps->stack_a->top->next->next->value);
    int a = ps->stack_a->top->value;
    int b = ps->stack_a->top->next->value;
    int c = ps->stack_a->top->next->next->value;

//    printf("Before sorting: a = %d, b = %d, c = %d\n", a, b, c);  // Debug print

    if (a < b && b < c)         // Case 1: a < b < c (already sorted)
        return;                 // Do nothing
    else if (a < c && c < b)    // Case 2: a < c < b
    {
  //      printf("Case 2: a < c < b\n");
        sa(ps);                 // Swap a and b
        ra(ps);                 // Rotate
    }
    else if (b < a && a < c)    // Case 3: b < a < c
    {
   //     printf("Case 3: b < a < c\n");
        sa(ps);                 // Swap a and b
    }
    else if (b < c && c < a)    // Case 4: b < c < a
    {
   //     printf("Case 4: b < c < a\n");
        ra(ps);                 // Rotate
    }
    else if (c < a && a < b)    // Case 5: c < a < b
    {
    //    printf("Case 5: c < a < b\n");
        rra(ps);                // Reverse rotate
    }
    else if (c < b && b < a)    // Case 6: c < b < a
    {
    //    printf("Case 6: c < b < a\n");
        sa(ps);                 // Swap a and b
        rra(ps);                // Reverse rotate
    }
}
#include "push_swap.h"

// Swap the first two elements of a stack
void swap(t_stack *stack)
{
    if (!stack || stack->size < 2)
        return;

    t_node *first = stack->top;
    t_node *second = first->next;

    first->next = second->next;
    second->next = first;
    stack->top = second;
}

// Swap the first two elements of stack_a
void sa(t_push_swap *ps)
{
    if (ps)
    {
        swap(ps->stack_a);
        write(1, "sa\n", 3);
    }
}

// Swap the first two elements of stack_b
void sb(t_push_swap *ps)
{
    if (ps)
    {
        swap(ps->stack_b);
        write(1, "sb\n", 3);
    }
}

// Swap both stack_a and stack_b
void ss(t_push_swap *ps)
{
    if (ps)
    {
        swap(ps->stack_a);
        swap(ps->stack_b);
        write(1, "ss\n", 3);
    }
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   free.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ceaugust <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/06 15:02:29 by ceaugust          #+#    #+#             */
/*   Updated: 2025/02/06 15:33:53 by ceaugust         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

void	*ft_free(char **splitted, size_t i)
{
    while (i--)
        free(splitted[i]);
    free(splitted);
    return (NULL);
}

void	free_stack(t_stack *stack)
{
	t_node *current = stack->top;
	t_node *next;

	while (current)
	{
		next = current->next;
		free_node(current);
		current = next;
	}
	stack->top = NULL;
	stack->size = 0;
}

void free_push_swap(t_push_swap *ps)
{
	if (ps)
		{
			if (ps->stack_a)
				free_stack(ps->stack_a);
			if (ps->stack_b)
				free_stack(ps->stack_b);
			free(ps->stack_a);
			free(ps->stack_b);
			free(ps);
		}
}
#include "push_swap.h"

size_t	ft_strlen(const char *s)
{
	int	i;

	i = 0;
	while (s[i])
		i++;
	return ((size_t)i);
}

size_t	ft_strlcpy(char *dst, const char *src, size_t size)
{
	size_t	i;
	size_t	srclen;

	srclen = ft_strlen(src);
	if (size == 0)
		return (srclen);
	i = 0;
	while (src[i] && (i < size -1))
	{
		dst[i] = src[i];
		i++;
	}
	dst[i] = 0;
	return (srclen);
}


char	*ft_substr(const char *s, unsigned int start, size_t len)
{
	size_t	slen;
	char	*ret;

	if (!s)
		return (NULL);
	slen = ft_strlen(s);
	if (start >= slen)
		return ((char *)"");
	if (len > slen - start)
		len = slen - start;
	ret = (char *)malloc(len + 1);
	if (!ret)
		return (NULL);
	ft_strlcpy(ret, s + start, len + 1);
	return (ret);
}
#include "push_swap.h" 

// Create a new node
t_node *create_node(int value)
{
    t_node *new_node = (t_node *)malloc(sizeof(t_node));
    if (!new_node)
        return (NULL);
    new_node->value = value;
    new_node->index = -1;  // Initialize to -1 (unset)
    new_node->next = NULL;
    return (new_node);
}

// Free a single node
void free_node(t_node *node)
{
    if (node)
        free(node);
}
#include "push_swap.h"

void pa(t_push_swap *ps)
{
    if (ps && ps->stack_b->size > 0)
    {
        t_node *node = pop(ps->stack_b);  // Pop the top node from stack_b
        if (node)
        {
            push(ps->stack_a, node);  // Push the node onto stack_a
            write(1, "pa\n", 3);
        }
    }
}

void pb(t_push_swap *ps)
{
    if (ps && ps->stack_a->size > 0)
    {
        t_node *node = pop(ps->stack_a);  // Pop the top node from stack_a
        if (node)
        {
            push(ps->stack_b, node);  // Push the node onto stack_b
            write(1, "pb\n", 3);
        }
    }
}
#include "push_swap.h"

// Reverse rotate a stack (last element becomes the top)
void reverse_rotate(t_stack *stack)
{
    if (!stack || stack->size < 2)
        return;

    t_node *current = stack->top;
    t_node *prev = NULL;

    // Traverse to the last element
    while (current->next)
    {
        prev = current;
        current = current->next;
    }

    prev->next = NULL;      // Detach the last element
    current->next = stack->top;  // Point it to the top
    stack->top = current;   // Update the top
}

// Reverse rotate stack_a
void rra(t_push_swap *ps)
{
    if (ps)
        {
        reverse_rotate(ps->stack_a);
        write(1, "rra\n", 4);
        }
}

// Reverse rotate stack_b
void rrb(t_push_swap *ps)
{
    if (ps)
    {
        reverse_rotate(ps->stack_b);
        write(1, "rrb\n", 4);
    }
}

// Reverse rotate both stack_a and stack_b
void rrr(t_push_swap *ps)
{
    if (ps)
    {
        reverse_rotate(ps->stack_a);
        reverse_rotate(ps->stack_b);
        write(1, "rrr\n", 4);
    }
}
#include "push_swap.h"

void	push_min_to_b(t_push_swap *ps)
{
	int		min;
	int		pos;
	int		i;
	int		rotations;
	int		direction;
	t_node	*curr;

	if (!ps || !ps->stack_a || ps->stack_a->size == 0)
		return;
	min = find_min(ps->stack_a);
	pos = 0;
	curr = ps->stack_a->top;
	while (curr)
	{
		if (curr->value == min)
			break;
		pos++;
		curr = curr->next;
	}
	if (pos <= ps->stack_a->size / 2)
	{
		rotations = pos;
		direction = 1;  // Use ra
	}
	else
	{
		rotations = ps->stack_a->size - pos;
		direction = -1; // Use rra
	}
	i = 0;
	while (i < rotations)
	{
		if (direction == 1)
			ra(ps);
		else
			rra(ps);
		i++;
	}
	pb(ps);
}

void	sort_five(t_push_swap *ps)
{
	if (!ps || !ps->stack_a || ps->stack_a->size != 5)
		return;
	push_min_to_b(ps); // Remove smallest
	push_min_to_b(ps); // Remove second smallest
	sort_three(ps);    // Sort the remaining three elements in A
	// Ensure B is in descending order (largest on top) so that pa restores proper order.
	if (ps->stack_b->size == 2 && ps->stack_b->top->value < ps->stack_b->top->next->value)
		sb(ps);
	pa(ps);
	pa(ps);
}
#include "push_swap.h"

void radix_sort(t_push_swap *ps)
{
    int max_bits = 0;
    int max_value;
    int i, j;
    int size;

    if (!ps || !ps->stack_a)
        return;

    /* max_value is the highest index; indexes range from 0 to (size - 1) */
    max_value = ps->stack_a->size - 1;
    while ((max_value >> max_bits) != 0)
        max_bits++;

    i = 0;
    while (i < max_bits)
    {
        size = ps->stack_a->size; /* get current size of A */
        j = 0;
        while (j < size)
        {
            /* Get the index from the top node of stack A */
            int num = ps->stack_a->top->index;
            if (((num >> i) & 1) == 0)
                pb(ps);
            else
                ra(ps);
            j++;
        }
        /* Once the pass is done, push back everything from stack B into stack A */
        while (ps->stack_b->size > 0)
            pa(ps);
        i++;
    }
}

#include "push_swap.h"

// Initialize an empty stack
t_stack *init_stack(void)
{
    t_stack *stack = (t_stack *)malloc(sizeof(t_stack));
    if (!stack)
        return (NULL);
    stack->top = NULL;
    stack->size = 0;
    return (stack);
}

// Push a node onto the stack
void push(t_stack *stack, t_node *node)
{
    if (!stack || !node)
        return;

    node->next = stack->top; // New node points to current top
    stack->top = node;       // Update top to new node
    stack->size++;
}

// Pop a node from the stack
t_node *pop(t_stack *stack)
{
    if (!stack || stack->size == 0)
        return (NULL);
    t_node *top_node = stack->top;
    stack->top = top_node->next;
    top_node->next = NULL;
    stack->size--;
    return (top_node);
}

// Return stack size
int stack_size(t_stack *stack)
{
    int size = 0;
    t_node *current = stack->top;  // Start from the top node of the stack

    while (current)
    {
        size++;
        current = current->next;  // Move to the next node
    }
    return (size);
}
#include "push_swap.h"

int is_sorted(t_stack *stack)
{
    t_node *current;

    if (!stack || !stack->top)
        return (1); // An empty stack is considered sorted

    current = stack->top;
    while (current->next)
    {
        if (current->value > current->next->value)
            return (0); // Not sorted
        current = current->next;
    }
    return (1); // Sorted
}

int find_min(t_stack *stack)
{
    t_node *current;
    int min;

    if (!stack || !stack->top)
        return (0); // Return 0 if the stack is empty

    current = stack->top;
    min = current->value;
    while (current)
    {
        if (current->value < min)
            min = current->value;
        current = current->next;
    }
    return (min);
}

int find_max(t_stack *stack)
{
    t_node *current;
    int max;

    if (!stack || !stack->top)
        return (0); // Return 0 if the stack is empty

    current = stack->top;
    max = current->value;
    while (current)
    {
        if (current->value > max)
            max = current->value;
        current = current->next;
    }
    return (max);
}

int	ft_atoi(const char *s)
{
	int	i;
	long	r;
	int	f;

	i = 0;
	r = 0;
	f = 1;
	while (s[i] == 32 || s[i] == '\t' || s[i] == '\r'
		|| s[i] == '\n' || s[i] == '\f' || s[i] == '\v')
		i++;
	if (s[i] == '+' || s[i] == '-')
	{
		if (s[i] == '-')
			f *= -1;
		i++;
	}
	while (s[i] >= '0' && s[i] <= '9')
	{
		r = r * 10 + (s[i] - '0');
		if ((f == 1 && r > 2147483647) || (f == -1 && -r < -2147483648))
			return (0);  // Overflow
		i++;
	}
	return (f * r);
}


int is_valid_integer(const char *str)
{
    if (!str || *str == '\0')
        return 0;  // Empty string is invalid

    int sign = 1;
    long result = 0;

    // Handle optional sign
    if (*str == '-')
    {
        sign = -1;
        str++;
    }
    else if (*str == '+')
    {
        str++;
    }

    // Convert string to long and check for overflow
    while (*str)
    {
        if (*str < '0' || *str > '9')
            return 0;  // Non-digit character found

        result = result * 10 + (*str - '0');

        // Check for overflow
        if ((sign == 1 && result > 2147483647) || (sign == -1 && -result < -2147483648))
            return 0;

        str++;
    }

    return 1;  // Valid integer
}
